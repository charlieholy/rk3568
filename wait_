///=> 小主题
DECLARE_COMPLETION_ONSTACK(done);  //栈上的 wait到之后释放 几乎是一次性

	if (unlikely(wait_for_completion_killable(&done))) {
		/*
		 * If I was SIGKILLed before kthreadd (or new kernel thread)
		 * calls complete(), leave the cleanup of this structure to
		 * that thread.
		 */
		if (xchg(&create->done, NULL))
			return ERR_PTR(-EINTR);
		/*
		 * kthreadd (or new kernel thread) will call complete()
		 * shortly.
		 */
		wait_for_completion(&done);
	}

//获取到done 唤醒
		struct completion *done = xchg(&create->done, NULL);

		if (!done) {
			kfree(create);
			return;
		}
		create->result = ERR_PTR(pid);
		complete(done);


/// ==>大主题
你想知道 log_wait 这个等待队列是如何和当前进程（current 任务）建立关联的
  —— 核心答案是：wait_event_interruptible(log_wait, ...) 宏内部会自动把当前进程（current）加入 log_wait 等待队列，无需手动调用 add_wait_queue。

核心结论
log_wait 是内核预定义的等待队列头（wait_queue_head_t），当执行 wait_event_interruptible(log_wait, cond) 时：
宏会自动创建一个「等待队列项（wait_queue_t）」，并绑定当前进程（current）；
把这个等待队列项添加到 log_wait 等待队列头中；
进程睡眠后，内核通过这个关联关系，能精准唤醒 log_wait 上的 current 进程。

第一步：先明确关键数据结构
在拆解宏之前，先认识两个核心结构体（简化版）：
c
运行
// 1. 等待队列头（log_wait 就是这个类型）：管理一个等待队列的链表头
typedef struct wait_queue_head {
    spinlock_t lock;
    struct list_head task_list; // 等待队列的链表，挂着所有等待的进程
} wait_queue_head_t;

// 2. 等待队列项：每个睡眠进程对应一个，绑定到等待队列头
typedef struct wait_queue {
    struct list_head entry;     // 链表节点，挂到 wait_queue_head_t 的 task_list
    struct task_struct *task;   // 指向当前进程（current）
    // 其他回调/标志...
} wait_queue_t;

// 内核中定义的 log_wait（在 kernel/printk/printk.c 中）
DECLARE_WAIT_QUEUE_HEAD(log_wait);
log_wait 是 wait_queue_head_t 类型，相当于「等待队列的总入口」；
每个睡眠的进程会生成一个 wait_queue_t，通过 entry 挂到 log_wait 的 task_list 链表上，task 字段指向 current。
第二步：拆解 wait_event_interruptible 宏的底层逻辑
wait_event_interruptible 是内核封装的宏，目的是简化「等待队列操作 + 睡眠」的流程，它的核心展开逻辑如下（简化版）：
c
运行
// 你看到的调用
wait_event_interruptible(log_wait, syslog_seq != log_next_seq);

// 宏展开后的核心逻辑（简化）
#define wait_event_interruptible(wq_head, condition)          \
({                                                             \
    int __ret = 0;                                             \
    // 1. 如果条件已经满足，直接返回，不睡眠
    if (!(condition)) {                                        \
        // 2. 定义一个等待队列项，自动绑定当前进程 current
        wait_queue_t __wait;                                   \
        init_wait_entry(&__wait, TASK_INTERRUPTIBLE);          \
        __wait.task = current; // 关键：绑定 current 到等待队列项
        
        // 3. 把 __wait 加入 wq_head（即 log_wait）的等待队列
        add_wait_queue(&wq_head, &__wait);                    \
        
        for (;;) {                                             \
            // 4. 把当前进程标记为 TASK_INTERRUPTIBLE（可中断睡眠）
            set_current_state(TASK_INTERRUPTIBLE);             \
            // 5. 再次检查条件，如果满足，跳出循环
            if (condition)                                     \
                break;                                         \
            // 6. 检查是否有信号，有则退出
            if (signal_pending(current)) {                     \
                __ret = -ERESTARTSYS;                          \
                break;                                         \
            }                                                  \
            // 7. 让出 CPU，调度器切换其他进程运行
            schedule();                                        \
        }                                                      \
        // 8. 恢复进程状态为 TASK_RUNNING
        __set_current_state(TASK_RUNNING);                     \
        // 9. 把等待队列项从 log_wait 中移除
        remove_wait_queue(&wq_head, &__wait);                  \
    }                                                          \
    __ret;                                                     \
})
第三步：关键步骤解读（进程和 log_wait 关联的核心）
我们聚焦「进程 ↔ log_wait」关联的核心步骤：
1. 绑定 current 到等待队列项
c
运行
wait_queue_t __wait;
init_wait_entry(&__wait, TASK_INTERRUPTIBLE);
__wait.task = current; // 直接把当前进程的 task_struct 指针赋值给 __wait.task
current 是内核全局宏，指向「当前正在执行的进程」（这里就是你的 klogd）；
这一步完成「等待队列项 → 进程」的单向关联。
2. 把等待队列项加入 log_wait
c
运行
add_wait_queue(&log_wait, &__wait);
add_wait_queue 底层会做两件事：
c
运行
void add_wait_queue(wait_queue_head_t *wqh, wait_queue_t *wait) {
    unsigned long flags;
    spin_lock_irqsave(&wqh->lock, flags);
    // 把 __wait 的 entry 节点挂到 log_wait 的 task_list 链表上
    list_add(&wait->entry, &wqh->task_list);
    spin_unlock_irqrestore(&wqh->lock, flags);
}
这一步完成「log_wait（等待队列头） → 等待队列项 → 进程」的完整关联；
此时 log_wait 的链表中就有了 klogd 进程的等待队列项。
3. 进程睡眠后，内核如何通过 log_wait 唤醒 current？
当内核有新日志时，会调用 wake_up_interruptible(&log_wait)，底层逻辑：
c
运行
void wake_up_interruptible(wait_queue_head_t *wqh) {
    spin_lock_irq(&wqh->lock);
    // 遍历 log_wait 的 task_list 链表
    list_for_each_entry(wait_queue_t *wait, &wqh->task_list, entry) {
        // 取出等待队列项绑定的进程（即 current，klogd）
        struct task_struct *task = wait->task;
        // 把进程状态改为 TASK_RUNNING，唤醒它
        if (task->state == TASK_INTERRUPTIBLE) {
            wake_up_process(task);
        }
    }
    spin_unlock_irq(&wqh->lock);
}
内核通过遍历 log_wait 的链表，找到所有绑定的进程（这里就是 klogd）；
通过 wait->task 找到 current，完成精准唤醒。
第四步：和 /proc/kmsg 等待队列的对比
为了帮你串联之前的知识，对比两种等待队列的关联方式：
表格
场景	等待队列	关联进程的方式	核心函数
syslog () 读取日志	log_wait	wait_event_interruptible 宏自动关联	add_wait_queue
poll /proc/kmsg	sock->wq->wait	poll_wait 调用 __pollwait 手动关联	__add_wait_queue
本质上：
wait_event_interruptible 是「封装好的快捷方式」，自动完成「创建队列项 → 绑定 current → 加入队列」；
poll_wait 是「手动方式」，需要自己定义回调函数完成关联，但底层都是调用 add_wait_queue 把进程加入等待队列。
总结
log_wait 和 current（klogd）的关联，是 wait_event_interruptible 宏自动完成的，无需手动调用 add_wait_queue；
核心步骤：宏创建 wait_queue_t 并绑定 current → 调用 add_wait_queue 把队列项加入 log_wait → 进程睡眠；
内核唤醒时，遍历 log_wait 的链表，通过 wait->task 找到 current，完成精准唤醒；
这个关联逻辑和 /proc/kmsg 的等待队列本质一致，只是 wait_event_interruptible 做了更高层的封装。
简单说：wait_event_interruptible(log_wait, ...) 就像「自动订书机」，一键完成「进程 ↔ log_wait」的绑定 + 睡眠；而 poll_wait 更像「手动订书机」，需要分步操作，但最终都是把进程钉到等待队列上。
