GPIO 组 GPIOX_A0~A7 GPIOX_B0~B7 GPIOX_C0~C7 GPIOX_D0~D7 
对应的 bit bit0~bit7 bit8~bit15 bit16~bit23 bit24~bit31 
GPIO3 0xFE760000
GPIO4 0xFE770000

ov13850: ov13850@10 {
		reset-gpios = <&gpio3 RK_PB6 GPIO_ACTIVE_HIGH>;
		pwdn-gpios = <&gpio4 RK_PB4 GPIO_ACTIVE_HIGH>;
root@ATK-DLRK3568:/sys/kernel/debug/dynamic_debug# devmem 0xFE760000
0x00004000
root@ATK-DLRK3568:/sys/kernel/debug/dynamic_debug# devmem 0xFE770000
0x00003000


GPIO0_C0
echo none > /sys/class/leds/work/trigger
PMU_GRF 0xFDC20000 
PMU_GRF_GPIO0C_IOMUX_L offset (0x0010) 2:0 RW 0x0  3'h0: GPIO0_C0 
PMU_GRF_GPIO0C_DS_0 offset (0x0090) 31:16 RW 0x0000 1'b1: Write access enable |5:0 RW 0x01 6'b111111: Level 5 
0xFDD60000 GPIO_SWPORT_DR_H 0x0004 
0xFDD60000 GPIO_SWPORT_DDR_H 0x000C
devmem 0xfdd60004 32 0x16001 //open


mknod /dev/led c 200 0

root@ATK-DLRK3568:/data# devmem 0xfe070000  32
0x3133302A

root@ATK-DLRK3568:/data# devmem 0xfdd60004
0x00006001
root@ATK-DLRK3568:/data# devmem 0xfdd60004 32 0x16000
root@ATK-DLRK3568:/data# devmem 0xfdd60004
0x00006000
root@ATK-DLRK3568:/data# devmem 0xfdd60004 32 0x16001
root@ATK-DLRK3568:/data# devmem 0xfdd60004
0x00006001


[ 8890.718593] PMU_GRF_GPIO0C_IOMUX_L = 0xfdc20010 PMU_GRF_GPIO0C_IOMUX_L_PI = ffffff800f34c010
[ 8890.718602] PMU_GRF_GPIO0C_DS_0 = 0xfdc20090 PMU_GRF_GPIO0C_DS_0_PI = ffffff800f34e090
[ 8890.718609] GPIO0_SWPORT_DR_H = 0xfdd60004 GPIO0_SWPORT_DR_H_PI = ffffff800f350004
[ 8890.718616] GPIO0_SWPORT_DDR_H = 0xfdd6000c GPIO0_SWPORT_DDR_H_PI = ffffff800f35200c

DSI-1
root@ATK-DLRK3568:/data# cat /dev/reg_dump
Register Dump Info:
Phys Address: 0xfe070000
Virt Address: 0xffffff8013aea000
Raw Value    : 0x3133302a
VOP
root@ATK-DLRK3568:/data# cat /dev/reg_dump
Register Dump Info:
Phys Address: 0xfe040004
Virt Address: 0xffffff800f1c0004
Raw Value    : 0x40158023

#include <linux/init.h>
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/io.h>
#include <linux/uaccess.h>
#include <linux/device.h>
#include <linux/slab.h>

// 设备核心定义
#define DEV_NAME        "reg_dump"
#define BUF_SIZE        32  // 接收用户传入地址的缓冲区（足够存十六进制地址）
static dev_t devno;                // 动态设备号
static struct cdev reg_cdev;       // 字符设备
static struct class *reg_class;    // 设备类（自动创建设备节点）
// 全局寄存器地址（支持动态修改）
static unsigned long g_reg_phys = 0xfe530e14; // 默认地址：你的CRD寄存器
static void __iomem *g_reg_vaddr;  // 动态映射的虚拟地址
static DEFINE_SPINLOCK(reg_lock);  // 自旋锁：保护地址修改/读取的原子性

// 寄存器读取函数（cat /dev/reg_dump 触发）
static ssize_t reg_read(struct file *filp, char __user *buf, size_t count, loff_t *ppos)
{
    char info[128] = {0};
    int len;
    ssize_t ret;
    u32 reg_val = 0;
    unsigned long phys_addr;
    void __iomem *vaddr;

    // 偏移量处理：一次性读取，非0直接返回
    if (*ppos != 0)
        return 0;

    // 加自旋锁：防止读取时地址被修改
    spin_lock(&reg_lock);
    phys_addr = g_reg_phys;
    vaddr = g_reg_vaddr;
    // 地址已映射则读取值
    if (vaddr)
        reg_val = ioread32(vaddr);
    spin_unlock(&reg_lock);

    // 构造输出：未设置合法地址则提示，否则输出十六进制
    if (!vaddr) {
        len = snprintf(info, sizeof(info), "Error: No valid register address set!\nUse: echo 0xXXXXXXX > /dev/%s\n", DEV_NAME);
    } else {
        len = snprintf(info, sizeof(info),
            "Register Dump Info:\n"
            "Phys Address: 0x%08lx\n"
            "Virt Address: 0x%px\n"  // 新增：读取时也打印虚拟地址（%px内核安全打印地址）
            "Raw Value    : 0x%08x\n",
            phys_addr, vaddr, reg_val);
    }

    // 安全拷贝到用户层：4.19内核兼容版min_t
    len = min_t(int, len, (int)count);
    ret = copy_to_user(buf, info, len);
    if (ret != 0) {
        pr_err("[%s] copy to user failed, uncopy: %zd bytes\n", DEV_NAME, ret);
        return -EFAULT;
    }

    *ppos += len;
    return len;
}

// 地址写入函数（echo 0xXXXXXXX > /dev/reg_dump 触发）
static ssize_t reg_write(struct file *filp, const char __user *buf, size_t count, loff_t *ppos)
{
    char *user_buf = NULL;
    unsigned long new_phys = 0;
    void __iomem *new_vaddr = NULL;
    int ret = -EINVAL;

    // 1. 分配内核缓冲区，拷贝用户层传入的地址字符串（如"0xffe00000"）
    user_buf = kzalloc(BUF_SIZE, GFP_KERNEL);
    if (!user_buf) {
        pr_err("[%s] kzalloc failed!\n", DEV_NAME);
        return -ENOMEM;
    }
    // 限制拷贝长度，避免溢出：4.19内核兼容版min_t
    count = min_t(size_t, count, (size_t)(BUF_SIZE - 1));
    if (copy_from_user(user_buf, buf, count)) {
        pr_err("[%s] copy from user failed!\n", DEV_NAME);
        goto free_buf;
    }

    // 2. 将字符串转为无符号长整型（支持0x前缀的十六进制，如0xffe00000）
    if (kstrtoul(user_buf, 16, &new_phys)) {
        pr_err("[%s] invalid address format! Use: 0xXXXXXXX (hex)\n", DEV_NAME);
        goto free_buf;
    }

    // 3. 校验地址合法性：4字节对齐（ARM32/64寄存器均为32位对齐）
    if (new_phys & 0x3) {
        pr_err("[%s] address 0x%08lx not 4-byte align! (ARM reg require)\n", DEV_NAME, new_phys);
        goto free_buf;
    }

    // 4. 映射新的物理地址为内核虚拟地址（映射4字节，32位寄存器）
    new_vaddr = ioremap(new_phys, 4);
    if (!new_vaddr) {
        pr_err("[%s] ioremap 0x%08lx failed! (invalid phys address)\n", DEV_NAME, new_phys);
        goto free_buf;
    }
    // ==============================================
    // 新增：打印用户动态设置的物理地址 + 映射后的虚拟地址
    // ==============================================
    pr_info("[%s] dynamic ioremap success:\n  Phys Address: 0x%08lx\n  Virt Address: 0x%px\n", 
            DEV_NAME, new_phys, new_vaddr);

    // 5. 加自旋锁：原子更新全局地址/虚拟地址，解除原有映射
    spin_lock(&reg_lock);
    if (g_reg_vaddr)
        iounmap(g_reg_vaddr); // 释放旧地址映射
    g_reg_phys = new_phys;   // 更新物理地址
    g_reg_vaddr = new_vaddr; // 更新虚拟地址
    spin_unlock(&reg_lock);

    pr_info("[%s] set reg address success: 0x%08lx\n", DEV_NAME, new_phys);
    ret = count; // 写入成功，返回实际写入的字节数

free_buf:
    kfree(user_buf); // 释放内核缓冲区
    return ret;
}

// 文件操作集：同时实现read/write，支持动态写地址+读值
static const struct file_operations reg_fops = {
    .owner  = THIS_MODULE,
    .read   = reg_read,
    .write  = reg_write,
};

// 模块初始化
static int __init reg_dump_init(void)
{
    int ret;
    struct device *dev; // 避免device_create的未使用变量警告

    // 1. 动态分配字符设备号
    ret = alloc_chrdev_region(&devno, 0, 1, DEV_NAME);
    if (ret < 0) {
        pr_err("[%s] alloc chrdev region failed: %d\n", DEV_NAME, ret);
        return ret;
    }
    pr_info("[%s] alloc devno success: major=%d, minor=%d\n", DEV_NAME, MAJOR(devno), MINOR(devno));

    // 2. 初始化并注册字符设备
    cdev_init(&reg_cdev, &reg_fops);
    reg_cdev.owner = THIS_MODULE;
    ret = cdev_add(&reg_cdev, devno, 1);
    if (ret < 0) {
        unregister_chrdev_region(devno, 1);
        pr_err("[%s] cdev add failed: %d\n", DEV_NAME, ret);
        return ret;
    }

    // 3. 映射默认物理地址（0xfe530e14）
    g_reg_vaddr = ioremap(g_reg_phys, 4);
    if (!g_reg_vaddr) {
        cdev_del(&reg_cdev);
        unregister_chrdev_region(devno, 1);
        pr_err("[%s] ioremap default 0x%08lx failed\n", DEV_NAME, g_reg_phys);
        return -ENOMEM;
    }
    // ==============================================
    // 新增：打印默认物理地址 + 映射后的虚拟地址
    // ==============================================
    pr_info("[%s] default ioremap success:\n  Phys Address: 0x%08lx\n  Virt Address: 0x%px\n", 
            DEV_NAME, g_reg_phys, g_reg_vaddr);

    // 4. 创建设备类+自动生成/dev/reg_dump节点
    reg_class = class_create(THIS_MODULE, DEV_NAME);
    if (IS_ERR(reg_class)) {
        iounmap(g_reg_vaddr);
        cdev_del(&reg_cdev);
        unregister_chrdev_region(devno, 1);
        ret = PTR_ERR(reg_class);
        pr_err("[%s] class create failed: %d\n", DEV_NAME, ret);
        return ret;
    }
    // 优化：增加dev变量，取错误码，避免警告
    dev = device_create(reg_class, NULL, devno, NULL, DEV_NAME);
    if (IS_ERR(dev)) {
        class_destroy(reg_class);
        iounmap(g_reg_vaddr);
        cdev_del(&reg_cdev);
        unregister_chrdev_region(devno, 1);
        ret = PTR_ERR(dev);
        pr_err("[%s] device create failed: %d\n", DEV_NAME, ret);
        return ret;
    }

    pr_info("[%s] nyx driver load success! Use:\n  echo 0xXXXXXXX > /dev/%s  (set address)\n  cat /dev/%s            (read value)\n", DEV_NAME, DEV_NAME, DEV_NAME);
    return 0;
}

// 模块卸载
static void __exit reg_dump_exit(void)
{
    // 反向释放所有资源
    device_destroy(reg_class, devno);
    class_destroy(reg_class);
    if (g_reg_vaddr) {
        // 新增：卸载时打印释放的映射地址
        pr_info("[%s] iounmap: Phys=0x%08lx, Virt=0x%px\n", DEV_NAME, g_reg_phys, g_reg_vaddr);
        iounmap(g_reg_vaddr);
    }
    cdev_del(&reg_cdev);
    unregister_chrdev_region(devno, 1);

    pr_info("[%s] driver unload success!\n", DEV_NAME);
}

// 驱动入口/出口
module_init(reg_dump_init);
module_exit(reg_dump_exit);

// 驱动信息
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Debug");
MODULE_DESCRIPTION("Dynamic Register Dump Driver (echo set addr, cat read val)");
MODULE_VERSION("2.1"); // 版本号更新为2.1
MODULE_ALIAS("reg_dump_dyn");
