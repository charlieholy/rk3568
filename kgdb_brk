remcom_in_buffer
remcom_out_buffer

NOKPROBE_SYMBOL

// 1. gdb 协议解析层
gdb_serial_stub()                // 解析串口传来的 "c" 命令
  └── kgdb_arch_handle_exception()  // 调用架构专属的命令处理
      └── kgdb_arch_update_addr()   // 处理 "c" 命令的地址参数（可选）
          └── kgdb_arch_set_pc()    // 设置 PC 寄存器（恢复执行地址）
// 2. 调试循环退出层
kgdb_cpu_enter()                 // 退出主 CPU 调试循环
  ├── raw_spin_unlock(&dbg_slave_lock)  // 释放从 CPU 锁，让从 CPU 恢复
  ├── atomic_set(&kgdb_active, -1)      // 清空主 CPU 标记
  ├── local_irq_restore(flags)          // 恢复 CPU 中断
  └── rcu_read_unlock()                 // 释放 RCU 锁
// 3. 异常返回层
kgdb_handle_exception()          // 完成异常处理，返回异常上下文
  └── el1_sync()                  // ARM64 异常返回，跳转到 PC 指向的地址继续执行

(gdb) disas
Dump of assembler code for function kgdb_breakpoint:
   0xffffff80081671ec <+0>:     stp     x29, x30, [sp,#-16]!
   0xffffff80081671f0 <+4>:     mov     x29, sp
   0xffffff80081671f4 <+8>:     mov     x0, x30
   0xffffff80081671f8 <+12>:    nop
   0xffffff80081671fc <+16>:    adrp    x2, 0xffffff80096b1000 <kretprobe_table_locks+2432>
   0xffffff8008167200 <+20>:    mov     w0, #0x1                        // #1
   0xffffff8008167204 <+24>:    add     x1, x2, #0x680
   0xffffff8008167208 <+28>:    stadd   w0, [x1]
   0xffffff800816720c <+32>:    dsb     st
=> 0xffffff8008167210 <+36>:    brk     #0x401
   0xffffff8008167214 <+40>:    dsb     st
   0xffffff8008167218 <+44>:    mov     w0, #0x1                        // #1
   0xffffff800816721c <+48>:    neg     w0, w0
   0xffffff8008167220 <+52>:    stadd   w0, [x1]
   0xffffff8008167224 <+56>:    ldp     x29, x30, [sp],#16
   0xffffff8008167228 <+60>:    ret
End of assembler dump.
(gdb) frame
#0  kgdb_breakpoint () at kernel/debug/debug_core.c:1091
1091            arch_kgdb_breakpoint();
(gdb) info line arch_kgdb_breakpoint
Line 32 of "./arch/arm64/include/asm/kgdb.h" starts at address 0xffffff8008167210 <kgdb_breakpoint+36>
   and ends at 0xffffff8008167214 <kgdb_breakpoint+40>.
(gdb)

arch/arm64/include/asm/kgdb.h
static inline void arch_kgdb_breakpoint(void)
{
	asm ("brk %0" : : "I" (KGDB_COMPILED_DBG_BRK_IMM));
}

static struct break_hook kgdb_compiled_brkpt_hook = {
	.esr_mask	= 0xffffffff,
	.esr_val	= (u32)ESR_ELx_VAL_BRK64(KGDB_COMPILED_DBG_BRK_IMM),
	.fn		= kgdb_compiled_brk_fn
};


////////////////////////////////////
#include <linux/module.h>
#include <linux/kernel.h>
#include <asm/kgdb.h>  // 包含 KGDB_COMPILED_DBG_BRK_IMM 定义

static inline void my_kgdb_break(void)
{
    // 内联汇编执行 brk #0x401（和内核原生写法一致）
    asm volatile ("brk %0" : : "I" (KGDB_COMPILED_DBG_BRK_IMM));
}

static int __init kgdb_brk_init(void)
{
    printk(KERN_INFO "KO: About to trigger kgdb breakpoint...\n");
    my_kgdb_break();  // 调用 brk #0x401
    printk(KERN_INFO "KO: Breakpoint done (unreachable if kgdb pauses)\n");
    return 0;
}

static void __exit kgdb_brk_exit(void)
{
    printk(KERN_INFO "KO: Module exit\n");
}

module_init(kgdb_brk_init);
module_exit(kgdb_brk_exit);
MODULE_LICENSE("GPL");

