#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/kprobes.h>
#include <linux/i2c.h>
#include <linux/string.h>
#include <linux/ctype.h>

// 定义kprobe结构体（挂钩RK3568真实导出的__i2c_transfer）
static struct kprobe kp_i2c_transfer;

// 格式化输出数据（十六进制+ASCII）
static void dump_i2c_data(const u8 *data, int len)
{
    int i;
    pr_cont("data (hex): ");
    for (i = 0; i < len; i++) {
        pr_cont("%02x ", data[i]);
    }
    pr_cont(" | (ascii): ");
    for (i = 0; i < len; i++) {
        pr_cont("%c", isprint(data[i]) ? data[i] : '.');
    }
    pr_cont("\n");
}

// -------------------------- I2C底层传输函数探针 --------------------------
static int __kprobes i2c_transfer_pre_handler(struct kprobe *p, struct pt_regs *regs)
{
    /* 
     * __i2c_transfer 函数原型（RK3568内核）：
     * int __i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)
     * ARM64寄存器映射：
     * regs->regs[0] → adap（I2C适配器）
     * regs->regs[1] → msgs（I2C消息数组）
     * regs->regs[2] → num（消息数量）
     */
    struct i2c_adapter *adap = (struct i2c_adapter *)(unsigned long)regs->regs[0];
    struct i2c_msg *msgs = (struct i2c_msg *)(unsigned long)regs->regs[1];
    int num = (int)regs->regs[2];
    int i;

    // 合法性校验
    if (!adap || !msgs || num <= 0 || num > 8) { // 限制最大8个消息，避免刷屏
        return 0;
    }

    // 遍历每个I2C消息，解析读写方向和数据
    for (i = 0; i < num; i++) {
        struct i2c_msg *msg = &msgs[i];
        if (!msg->buf || msg->len <= 0 || msg->len > 1024) {
            continue;
        }

        // 区分读/写方向（I2C_M_RD为读标志）
        if (msg->flags & I2C_M_RD) {
            pr_info("[I2C-READ ] adapter: %d, dev_addr: 0x%02x, len: %d (pending)...\n",
                    adap->nr, msg->addr, msg->len);
        } else {
            pr_info("[I2C-WRITE] adapter: %d, dev_addr: 0x%02x, len: %d, ",
                    adap->nr, msg->addr, msg->len);
            dump_i2c_data(msg->buf, msg->len);
        }
    }

    return 0;
}

// -------------------------- 模块初始化/卸载 --------------------------
static int __init i2c_kprobe_init(void)
{
    int ret;

    // 核心修改：挂钩RK3568真实导出的__i2c_transfer（带双下划线）
    kp_i2c_transfer.symbol_name = "__i2c_transfer";
    kp_i2c_transfer.pre_handler = i2c_transfer_pre_handler;
    
    // 注册kprobe
    ret = register_kprobe(&kp_i2c_transfer);
    if (ret < 0) {
        pr_err("Failed to register kprobe for __i2c_transfer: %d\n", ret);
        return ret;
    }

    pr_info("I2C kprobe driver loaded successfully (RK3568 ARM64)\n");
    return 0;
}

static void __exit i2c_kprobe_exit(void)
{
    unregister_kprobe(&kp_i2c_transfer);
    pr_info("I2C kprobe driver unloaded successfully\n");
}

module_init(i2c_kprobe_init);
module_exit(i2c_kprobe_exit);

// 模块信息
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Custom");
MODULE_DESCRIPTION("Kprobe driver to dump I2C data (RK3568 ARM64)");
MODULE_VERSION("5.0");
