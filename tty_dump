// so far , it only work for tx seems.
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/kprobes.h>
#include <linux/tty.h>
#include <linux/fs.h>
#include <linux/uaccess.h>
#include <linux/string.h>
#include <linux/types.h>

// 从你的日志提取的稳定特征
#define TARGET_TTY_INDEX 265  // ttyS8 实际 index=265
#define TARGET_TTY_TYPE  22208 // 硬件串口 type=22208
#define MAX_DUMP_LEN     32
#define DEBUG_LOG        0     // 关闭调试日志，只打印核心数据

// 保存 tty_read 入参
static struct file *g_tty_read_file = NULL;
static char __user *g_tty_read_buf = NULL;

// -------------------- 核心过滤：基于稳定的 index+type 特征 --------------------
static inline int is_target_tty(struct tty_struct *tty)
{
    if (!tty || !tty->driver) {
        return 0;
    }

    // 匹配从日志提取的稳定特征
    if (tty->index == TARGET_TTY_INDEX && tty->driver->type == TARGET_TTY_TYPE) {
        return 1;
    }

    return 0;
}

// -------------------- TX：tty_write 监控 --------------------
static int __kprobes tty_write_pre_handler(struct kprobe *p, struct pt_regs *regs)
{
    struct file *file = (struct file *)regs->regs[0];
    const char __user *buf = (const char __user *)regs->regs[1];
    size_t count = (size_t)regs->regs[2];
    struct tty_struct *tty = NULL;
    unsigned char kbuf[MAX_DUMP_LEN] = {0};
    int copy_len, i;

    // 解析 tty_struct
    if (file && file->private_data) {
        tty = (struct tty_struct *)file->private_data;
    }

    // 匹配目标串口
    if (!is_target_tty(tty)) {
        return 0;
    }

    // 打印 TX 数据
    if (count > 0) {
        copy_len = (count > MAX_DUMP_LEN) ? MAX_DUMP_LEN : count;
        if (copy_from_user(kbuf, buf, copy_len) == 0) {
            printk(KERN_INFO "[UART8 TX] len: %zu | data: ", count);
            for (i = 0; i < copy_len; i++) {
                printk(KERN_CONT "%02x ", kbuf[i]);
            }
            printk(KERN_CONT "\n");
        }
    }

    return 0;
}

// -------------------- RX：tty_read 监控 --------------------
static int __kprobes tty_read_pre_handler(struct kprobe *p, struct pt_regs *regs)
{
    struct file *file = (struct file *)regs->regs[0];
    char __user *buf = (char __user *)regs->regs[1];
    struct tty_struct *tty = NULL;

    // 保存入参
    g_tty_read_file = file;
    g_tty_read_buf = buf;

    // 提前过滤
    if (file && file->private_data) {
        tty = (struct tty_struct *)file->private_data;
    }
    if (!is_target_tty(tty)) {
        g_tty_read_file = NULL;
        g_tty_read_buf = NULL;
        return 0;
    }

    return 0;
}

static void __kprobes tty_read_post_handler(struct kprobe *p, struct pt_regs *regs, unsigned long flags)
{
    ssize_t read_len = (ssize_t)regs->regs[0];
    struct file *file = g_tty_read_file;
    char __user *buf = g_tty_read_buf;
    struct tty_struct *tty = NULL;
    unsigned char kbuf[MAX_DUMP_LEN] = {0};
    int copy_len, i;

    // 重置全局变量
    g_tty_read_file = NULL;
    g_tty_read_buf = NULL;

    // 过滤无效数据
    if (read_len <= 0 || !file || !buf) {
        return;
    }

    // 二次验证
    if (file->private_data) {
        tty = (struct tty_struct *)file->private_data;
    }
    if (!is_target_tty(tty)) {
        return;
    }

    // 打印 RX 数据
    copy_len = (read_len > MAX_DUMP_LEN) ? MAX_DUMP_LEN : read_len;
    if (copy_from_user(kbuf, buf, copy_len) == 0) {
        printk(KERN_INFO "[UART8 RX] len: %zd | data: ", read_len);
        for (i = 0; i < copy_len; i++) {
            printk(KERN_CONT "%02x ", kbuf[i]);
        }
        printk(KERN_CONT "\n");
    }
}

// -------------------- Kprobe 定义 & 模块生命周期 --------------------
static struct kprobe kp_tty_write = {
    .symbol_name    = "tty_write",
    .pre_handler    = tty_write_pre_handler,
};

static struct kprobe kp_tty_read = {
    .symbol_name    = "tty_read",
    .pre_handler    = tty_read_pre_handler,
    .post_handler   = tty_read_post_handler,
};

static int __init uart8_dump_init(void)
{
    int ret;

    ret = register_kprobe(&kp_tty_write);
    if (ret < 0) {
        printk(KERN_ERR "register tty_write kprobe failed: %d\n", ret);
        goto err_tty_write;
    }

    ret = register_kprobe(&kp_tty_read);
    if (ret < 0) {
        printk(KERN_ERR "register tty_read kprobe failed: %d\n", ret);
        goto err_tty_read;
    }

    printk(KERN_INFO "UART8 TX/RX dump loaded (index: %d, type: %d)\n",
           TARGET_TTY_INDEX, TARGET_TTY_TYPE);
    return 0;

err_tty_read:
    unregister_kprobe(&kp_tty_write);
err_tty_write:
    return ret;
}

static void __exit uart8_dump_exit(void)
{
    unregister_kprobe(&kp_tty_read);
    unregister_kprobe(&kp_tty_write);
    printk(KERN_INFO "UART8 TX/RX dump unloaded\n");
}

module_init(uart8_dump_init);
module_exit(uart8_dump_exit);

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("RK3568 ttyS8 TX/RX Dump (Stable Index+Type)");
MODULE_AUTHOR("Custom");
