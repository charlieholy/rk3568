(gdb) p ((struct v4l2_ctrl*)hdl->ctrls->next)->ops
$16 = (const struct v4l2_ctrl_ops *) 0x0
(gdb) p ((struct v4l2_ctrl*)hdl->ctrls->next->next)
$17 = (struct v4l2_ctrl *) 0xffffffc0e64f7d00
(gdb) p ((struct v4l2_ctrl*)hdl->ctrls->next->next)->name
$18 = 0xffffff8009203d89 "Link Frequency"
(gdb) p ((struct v4l2_ctrl*)hdl->ctrls->next->next->next)->name
$19 = 0xffffff8009203d98 "Pixel Rate"
(gdb) p ((struct v4l2_ctrl*)hdl->ctrls->next->next->next->next)->name
$20 = 0xffffff8009203cd3 "Image Source Controls"
(gdb) p ((struct v4l2_ctrl*)hdl->ctrls->next->next->next->next->next)->name
$21 = 0xffffff8009203cfb "Horizontal Blanking"
(gdb) p ((struct v4l2_ctrl*)hdl->ctrls->next->next->next->next->next->next)->name
$22 = 0xffffff8009203ce9 "Vertical Blanking"
(gdb) p ((struct v4l2_ctrl*)hdl->ctrls->next->next->next->next->next->next)->ops
$23 = (const struct v4l2_ctrl_ops *) 0xffffff8008f639b8 <ov13850_ctrl_ops>
(gdb) p ((struct v4l2_ctrl*)hdl->ctrls->next->next->next->next->next->next)->name
$24 = 0xffffff8009203ce9 "Vertical Blanking"
(gdb) p ((struct v4l2_ctrl*)hdl->ctrls->next->next->next->next->next->next->next)->name
$25 = 0xffffff80092026d7 "User Controls"
(gdb) p ((struct v4l2_ctrl*)hdl->ctrls->next->next->next->next->next->next->next->next)->name
$26 = 0xffffff8009203732 "Exposure"
(gdb) p ((struct v4l2_ctrl*)hdl->ctrls->next->next->next->next->next->next->next->next)->ops
$27 = (const struct v4l2_ctrl_ops *) 0xffffff8008f639b8 <ov13850_ctrl_ops>
(gdb) p ((struct v4l2_ctrl*)hdl->ctrls->next->next->next->next->next->next->next->next)->name
$28 = 0xffffff8009203732 "Exposure"
(gdb) p ((struct v4l2_ctrl*)hdl->ctrls->next->next->next->next->next->next->next->next->next)->name
$29 = 0xffffff8009203d0f "Analogue Gain"
(gdb) p ((struct v4l2_ctrl*)hdl->ctrls->next->next->next->next->next->next->next->next->next->next)->name
$30 = 0xffffff8009203da3 "Test Pattern"
(gdb) p ((struct v4l2_ctrl*)hdl->ctrls->next->next->next->next->next->next->next->next->next->next)->ops
$31 = (const struct v4l2_ctrl_ops *) 0xffffff8008f639b8 <ov13850_ctrl_ops>
(gdb) p ((struct v4l2_ctrl*)hdl->ctrls->next->next->next->next->next->next->next->next->next->next)
$32 = (struct v4l2_ctrl *) 0xffffffc0e64e1600
(gdb) p *((struct v4l2_ctrl*)hdl->ctrls->next->next->next->next->next->next->next->next->next->next)
$33 = {node = {next = 0xffffffc0e66302c0, prev = 0xffffffc0e64e1500}, ev_subs = {next = 0xffffffc0e64e1610,
    prev = 0xffffffc0e64e1610}, handler = 0xffffffc0e6630280, cluster = 0xffffffc0e64e0898, ncontrols = 1, done = 0,
  is_new = 1, has_changed = 0, is_private = 0, is_auto = 0, is_int = 1, is_string = 0, is_ptr = 0, is_array = 0,
  has_volatiles = 0, call_notify = 0, manual_mode_value = 0, ops = 0xffffff8008f639b8 <ov13850_ctrl_ops>,
  type_ops = 0xffffff8008f6a938 <std_type_ops>, id = 10422531, name = 0xffffff8009203da3 "Test Pattern",
  type = V4L2_CTRL_TYPE_MENU, minimum = 0, maximum = 4, default_value = 0, elems = 1, elem_size = 4, dims = {0, 0, 0,
    0}, nr_of_dims = 0, {step = 0, menu_skip_mask = 0}, {qmenu = 0xffffff8008f639d0 <ov13850_test_pattern_menu>,
    qmenu_int = 0xffffff8008f639d0 <ov13850_test_pattern_menu>}, flags = 0, priv = 0x0, val = 0, cur = {val = 0},
  p_new = {p_s32 = 0xffffffc0e64e16b8, p_s64 = 0xffffffc0e64e16b8, p_u8 = 0xffffffc0e64e16b8 "",
    p_u16 = 0xffffffc0e64e16b8, p_u32 = 0xffffffc0e64e16b8, p_char = 0xffffffc0e64e16b8 "", p = 0xffffffc0e64e16b8},
  p_cur = {p_s32 = 0xffffffc0e64e16bc, p_s64 = 0xffffffc0e64e16bc, p_u8 = 0xffffffc0e64e16bc "",
    p_u16 = 0xffffffc0e64e16bc, p_u32 = 0xffffffc0e64e16bc, p_char = 0xffffffc0e64e16bc "", p = 0xffffffc0e64e16bc}}
(gdb)



media-ctl -p // dump v4l2_subdev

root@ATK-DLRK3568:/# media-ctl -p
Media controller API version 4.19.255

Media device information
------------------------
driver          rkisp-vir0
model           rkisp0
serial
bus info
hw revision     0x0
driver version  4.19.255

Device topology
- entity 1: rkisp-isp-subdev (4 pads, 7 links)
            type V4L2 subdev subtype Unknown flags 0
            device node name /dev/v4l-subdev0
        pad0: Sink
                [fmt:SBGGR10_1X10/2112x1568 field:none
                 crop.bounds:(0,0)/2112x1568
                 crop:(0,0)/2112x1568]
                <- "rkisp-csi-subdev":1 [ENABLED]
                <- "rkisp_rawrd0_m":0 [ENABLED]
                <- "rkisp_rawrd2_s":0 [ENABLED]
        pad1: Sink
                <- "rkisp-input-params":0 [ENABLED]
        pad2: Source
                [fmt:YUYV8_2X8/2112x1568 field:none colorspace:smpte170m quantization:full-range
                 crop.bounds:(0,0)/2112x1568
                 crop:(0,0)/2112x1568]
                -> "rkisp_mainpath":0 [ENABLED]
                -> "rkisp_selfpath":0 [ENABLED]
        pad3: Source
                -> "rkisp-statistics":0 [ENABLED]

- entity 6: rkisp-csi-subdev (6 pads, 5 links)
            type V4L2 subdev subtype Unknown flags 0
            device node name /dev/v4l-subdev1
        pad0: Sink
                [fmt:SBGGR10_1X10/2112x1568 field:none]
                <- "rockchip-csi2-dphy0":1 [ENABLED]
        pad1: Source
                [fmt:SBGGR10_1X10/2112x1568 field:none]
                -> "rkisp-isp-subdev":0 [ENABLED]
        pad2: Source
                [fmt:SBGGR10_1X10/2112x1568 field:none]
                -> "rkisp_rawwr0":0 [ENABLED]
        pad3: Source
                [fmt:SBGGR10_1X10/2112x1568 field:none]
        pad4: Source
                [fmt:SBGGR10_1X10/2112x1568 field:none]
                -> "rkisp_rawwr2":0 [ENABLED]
        pad5: Source
                [fmt:SBGGR10_1X10/2112x1568 field:none]
                -> "rkisp_rawwr3":0 [ENABLED]

- entity 13: rkisp_mainpath (1 pad, 1 link)
             type Node subtype V4L flags 0
             device node name /dev/video0
        pad0: Sink
                <- "rkisp-isp-subdev":2 [ENABLED]

- entity 19: rkisp_selfpath (1 pad, 1 link)
             type Node subtype V4L flags 0
             device node name /dev/video1
        pad0: Sink
                <- "rkisp-isp-subdev":2 [ENABLED]

- entity 25: rkisp_rawwr0 (1 pad, 1 link)
             type Node subtype V4L flags 0
             device node name /dev/video2
        pad0: Sink
                <- "rkisp-csi-subdev":2 [ENABLED]

- entity 31: rkisp_rawwr2 (1 pad, 1 link)
             type Node subtype V4L flags 0
             device node name /dev/video3
        pad0: Sink
                <- "rkisp-csi-subdev":4 [ENABLED]

- entity 37: rkisp_rawwr3 (1 pad, 1 link)
             type Node subtype V4L flags 0
             device node name /dev/video4
        pad0: Sink
                <- "rkisp-csi-subdev":5 [ENABLED]

- entity 43: rkisp_rawrd0_m (1 pad, 1 link)
             type Node subtype V4L flags 0
             device node name /dev/video5
        pad0: Source
                -> "rkisp-isp-subdev":0 [ENABLED]

- entity 49: rkisp_rawrd2_s (1 pad, 1 link)
             type Node subtype V4L flags 0
             device node name /dev/video6
        pad0: Source
                -> "rkisp-isp-subdev":0 [ENABLED]

- entity 55: rkisp-statistics (1 pad, 1 link)
             type Node subtype V4L flags 0
             device node name /dev/video7
        pad0: Sink
                <- "rkisp-isp-subdev":3 [ENABLED]

- entity 61: rkisp-input-params (1 pad, 1 link)
             type Node subtype V4L flags 0
             device node name /dev/video8
        pad0: Source
                -> "rkisp-isp-subdev":1 [ENABLED]

- entity 67: rockchip-csi2-dphy0 (2 pads, 2 links)
             type V4L2 subdev subtype Unknown flags 0
             device node name /dev/v4l-subdev2
        pad0: Sink
                [fmt:SBGGR10_1X10/2112x1568@10000/300000 field:none]
                <- "m00_b_ov13850 4-0010":0 [ENABLED]
        pad1: Source
                [fmt:SBGGR10_1X10/2112x1568@10000/300000 field:none]
                -> "rkisp-csi-subdev":0 [ENABLED]

- entity 70: m00_b_ov13850 4-0010 (1 pad, 1 link)
             type V4L2 subdev subtype Sensor flags 0
             device node name /dev/v4l-subdev3
        pad0: Source
                [fmt:SBGGR10_1X10/2112x1568@10000/300000 field:none]
                -> "rockchip-csi2-dphy0":0 [ENABLED]


v4l2-ctl -d /dev/video1 --stream-mmap --stream-count=10 --stream-to=test.yuv
    ==> vb2_mmap

#0  __fill_vb2_buffer (vb=0xffffffc0e592c400, pb=0xffffff80100b3c58, planes=0xffffffc0e592c428)
    at drivers/media/common/videobuf2/videobuf2-v4l2.c:351
#1  0xffffff80089b1648 in __prepare_mmap (pb=<optimized out>, vb=<optimized out>)
    at drivers/media/common/videobuf2/videobuf2-core.c:991
#2  __buf_prepare (vb=0xffffffc0e592c400, pb=<optimized out>) at drivers/media/common/videobuf2/videobuf2-core.c:1275
#3  0xffffff80089b1890 in vb2_core_qbuf (q=0xffffffc0e78c19a0, index=<optimized out>, pb=0xffffff80100b3c58)
    at drivers/media/common/videobuf2/videobuf2-core.c:1408
#4  0xffffff80089b4ed4 in vb2_qbuf (q=0xffffffc0e78c19a0, b=0xffffff80100b3c58)
    at drivers/media/common/videobuf2/videobuf2-v4l2.c:624
#5  0xffffff80089b4f30 in vb2_ioctl_qbuf (file=0xffffffc0e5980500, priv=<optimized out>, p=0xffffff80100b3c58)
    at drivers/media/common/videobuf2/videobuf2-v4l2.c:833
#6  0xffffff800898fe20 in v4l_qbuf (ops=0xffffff8008f655b0 <rkisp_v4l2_ioctl_ops>, file=0xffffffc0e5980500,
    fh=0xffffffc0e6244400, arg=0xffffff80100b3c58) at drivers/media/v4l2-core/v4l2-ioctl.c:1947
#7  0xffffff8008992a3c in __video_do_ioctl (file=0xffffffc0e5980500, cmd=3227014671, arg=0xffffff80100b3c58)
    at drivers/media/v4l2-core/v4l2-ioctl.c:2880
#8  0xffffff800898f360 in video_usercopy (file=<optimized out>, cmd=3227014671, arg=549284432472, func=<optimized out>)
    at drivers/media/v4l2-core/v4l2-ioctl.c:3054
#9  0xffffff800898f608 in video_ioctl2 (file=0xffffffc0e5980500, cmd=3227014671, arg=549284432472)
    at drivers/media/v4l2-core/v4l2-ioctl.c:3100
#10 0xffffff800898ac58 in v4l2_ioctl (filp=0xffffffc0e5980500, cmd=3227014671, arg=549284432472)
    at drivers/media/v4l2-core/v4l2-dev.c:364
#11 0xffffff80082297d0 in vfs_ioctl (filp=0xffffffc0e5980500, cmd=3227014671, arg=549284432472) at fs/ioctl.c:46
#12 0xffffff8008229f10 in do_vfs_ioctl (filp=0xffffffc0e5980500, fd=3, cmd=3227014671, arg=549284432472)
    at fs/ioctl.c:690
#13 0xffffff800822a880 in ksys_ioctl (fd=3, cmd=3227014671, arg=549284432472) at fs/ioctl.c:705
#14 0xffffff800822a8d8 in __do_sys_ioctl (arg=<optimized out>, cmd=<optimized out>, fd=<optimized out>)
    at fs/ioctl.c:712
    
ffmpeg -f rawvideo -pixel_format yuv420p -video_size 1920x1080 -i test.yuv -vf "format=bgra" -f fbdev /dev/fb0
ffmpeg -y -i 'train video of 3GPP part1.wmv' -vf scale=1920:1080 -pix_fmt bgra -f fbdev /dev/fb0
ffmpeg -y -i 'train video of 3GPP part1.wmv' -vn -f alsa hw:0,0

gst-launch-1.0 v4l2src device=/dev/video0 ! video/x-raw,format=NV12,width=1920,height=1080,framerate=30/1 ! kmssink sync=0

isp ready
(gdb) bt
#0  rkisp_isp_isr (isp_mis=64, isp3a_mis=0, dev=0xffffffc0e7890080) at drivers/media/platform/rockchip/isp/rkisp.c:2929
#1  0xffffff80089cf00c in isp_irq_hdl (irq=<optimized out>, ctx=0xffffffc0e92a2010)
    at drivers/media/platform/rockchip/isp/hw.c:174
#2  0xffffff80081130a4 in __handle_irq_event_percpu (desc=0xffffffc0e9b86000, flags=0xffffff8008003ee4)
    at kernel/irq/handle.c:149
#3  0xffffff8008113238 in handle_irq_event_percpu (desc=0xffffffc0e9b86000) at kernel/irq/handle.c:189
#4  0xffffff80081132dc in handle_irq_event (desc=0xffffffc0e9b86000) at kernel/irq/handle.c:206
#5  0xffffff8008117d6c in handle_fasteoi_irq (desc=0xffffffc0e9b86000) at kernel/irq/chip.c:743
#6  0xffffff80081120e4 in generic_handle_irq_desc (desc=<optimized out>) at ./include/linux/irqdesc.h:155
#7  generic_handle_irq (irq=36) at kernel/irq/irqdesc.c:639
#8  0xffffff800811287c in __handle_domain_irq (domain=0xffffffc00020a200, hwirq=<optimized out>, lookup=true,
    regs=0xffffff800fa53ec0) at kernel/irq/irqdesc.c:676
#9  0xffffff8008081174 in handle_domain_irq (regs=<optimized out>, hwirq=<optimized out>, domain=<optimized out>)
    at ./include/linux/irqdesc.h:173
#10 gic_handle_irq (regs=0xffffff800fa53ec0) at drivers/irqchip/irq-gic-v3.c:373
#11 0xffffff80080834fc in el0_irq () at arch/arm64/kernel/entry.S:878
Backtrace stopped: Cannot access memory at address 0xffffff800fa540d8
(gdb)

mipi_irq_hdl
mi_irq_hdl
isp_irq_hdl

c code ready one frame yuv then show it via ffmpeg
//////////////
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include <stdint.h>
#include <sys/mman.h>
#include <sys/ioctl.h>
#include <linux/videodev2.h>

// 手动定义必要宏（适配老版本头文件）
#ifndef V4L2_PIX_FMT_NV12_MPLANE
#define V4L2_PIX_FMT_NV12_MPLANE v4l2_fourcc('N', 'V', '1', '2')
#endif
#ifndef v4l2_fourcc
#define v4l2_fourcc(a,b,c,d) ((__u32)(a) | ((__u32)(b) << 8) | ((__u32)(c) << 16) | ((__u32)(d) << 24))
#endif

// RK3568摄像头设备节点
#define CAMERA_DEV "/dev/video-camera0"
#define SAVE_PATH "/data/camera_frame.nv12"
#define WIDTH  1280
#define HEIGHT 720
#define PIX_FMT V4L2_PIX_FMT_NV12_MPLANE

// 缓冲区结构体
struct Buffer {
    void *start;
    int length;
};

struct Buffer *buffers;
int buffer_count = 0;

// 错误处理函数
static void err_exit(const char *msg) {
    fprintf(stderr, "[ERROR] %s: %s (errno=%d)\n", msg, strerror(errno), errno);
    exit(EXIT_FAILURE);
}

static int camera_init(int fd) {
    struct v4l2_capability cap;
    struct v4l2_format fmt;
    struct v4l2_requestbuffers req;
    struct v4l2_plane planes[1];

    // 1. 检查多平面捕获能力
    if (ioctl(fd, VIDIOC_QUERYCAP, &cap) == -1)
        err_exit("VIDIOC_QUERYCAP");
    if (!(cap.capabilities & V4L2_CAP_VIDEO_CAPTURE_MPLANE)) {
        err_exit("摄像头仅支持多平面捕获，请确认设备节点为/video-camera0");
    }
    if (!(cap.capabilities & V4L2_CAP_STREAMING))
        err_exit("摄像头不支持流模式");

    // 2. 配置多平面视频格式
    memset(&fmt, 0, sizeof(fmt));
    fmt.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
    fmt.fmt.pix_mp.width = WIDTH;
    fmt.fmt.pix_mp.height = HEIGHT;
    fmt.fmt.pix_mp.pixelformat = PIX_FMT;
    fmt.fmt.pix_mp.field = V4L2_FIELD_NONE;
    fmt.fmt.pix_mp.num_planes = 1;

    if (ioctl(fd, VIDIOC_S_FMT, &fmt) == -1)
        err_exit("VIDIOC_S_FMT（多平面）");
    if (ioctl(fd, VIDIOC_G_FMT, &fmt) == -1)
        err_exit("VIDIOC_G_FMT（多平面）");
    printf("实际配置：%dx%d, 多平面NV12格式\n", 
           fmt.fmt.pix_mp.width, fmt.fmt.pix_mp.height);

    // 3. 申请多平面缓冲区
    memset(&req, 0, sizeof(req));
    req.count = 4;
    req.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
    req.memory = V4L2_MEMORY_MMAP;
    if (ioctl(fd, VIDIOC_REQBUFS, &req) == -1)
        err_exit("VIDIOC_REQBUFS（多平面）");
    buffer_count = req.count;

    // 4. 分配缓冲区结构体
    buffers = calloc(buffer_count, sizeof(struct Buffer));
    if (!buffers) err_exit("calloc buffers");

    // 5. 映射缓冲区（终极适配：用data_offset替代offset）
    struct v4l2_buffer buf;
    for (int i = 0; i < buffer_count; i++) {
        memset(&buf, 0, sizeof(buf));
        buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
        buf.memory = V4L2_MEMORY_MMAP;
        buf.index = i;
        buf.length = fmt.fmt.pix_mp.num_planes;
        buf.m.planes = planes;

        if (ioctl(fd, VIDIOC_QUERYBUF, &buf) == -1)
            err_exit("VIDIOC_QUERYBUF（多平面）");
        
        // 核心修复：用data_offset（你环境中唯一存在的偏移量成员）
        buffers[i].length = planes[0].length;
        buffers[i].start = mmap(NULL, planes[0].length, 
                               PROT_READ | PROT_WRITE, MAP_SHARED, 
                               fd, (off_t)planes[0].data_offset);  // 改为data_offset

        if (buffers[i].start == MAP_FAILED)
            err_exit("mmap（多平面）");

        if (ioctl(fd, VIDIOC_QBUF, &buf) == -1)
            err_exit("VIDIOC_QBUF（多平面）");
    }

    return 0;
}

static int capture_and_save(int fd) {
    struct v4l2_buffer buf;
    struct v4l2_plane planes[1];
    FILE *fp = NULL;

    // 启动流捕获
    enum v4l2_buf_type type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
    if (ioctl(fd, VIDIOC_STREAMON, &type) == -1)
        err_exit("VIDIOC_STREAMON（多平面）");

    // 取出缓冲区（增加重试，适配摄像头启动延迟）
    memset(&buf, 0, sizeof(buf));
    buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
    buf.memory = V4L2_MEMORY_MMAP;
    buf.length = 1;
    buf.m.planes = planes;

    int retries = 20;
    while (retries-- > 0) {
        if (ioctl(fd, VIDIOC_DQBUF, &buf) == 0) break;
        if (errno != EAGAIN) err_exit("VIDIOC_DQBUF（多平面）");
        usleep(100000);  // 等待100ms
    }
    if (retries < 0) err_exit("缓冲区无数据（超时），请检查摄像头硬件");

    // 保存NV12数据到文件
    fp = fopen(SAVE_PATH, "wb");
    if (!fp) err_exit("fopen " SAVE_PATH);
    fwrite(buffers[buf.index].start, 1, planes[0].bytesused, fp);
    fclose(fp);
    printf("✅ 帧数据已保存到：%s（大小：%d 字节）\n", SAVE_PATH, planes[0].bytesused);

    // 缓冲区重新入队
    if (ioctl(fd, VIDIOC_QBUF, &buf) == -1)
        err_exit("VIDIOC_QBUF（多平面）");

    // 停止流捕获
    if (ioctl(fd, VIDIOC_STREAMOFF, &type) == -1)
        err_exit("VIDIOC_STREAMOFF（多平面）");

    return 0;
}

static void cleanup(int fd) {
    for (int i = 0; i < buffer_count; i++)
        munmap(buffers[i].start, buffers[i].length);
    free(buffers);
    close(fd);
}

int main() {
    // 修复语法错误：正确拼接字符串（先定义错误信息）
    char open_err_msg[128];
    snprintf(open_err_msg, sizeof(open_err_msg), "open %s", CAMERA_DEV);

    // 打开摄像头设备（非阻塞模式）
    int fd = open(CAMERA_DEV, O_RDWR | O_NONBLOCK, 0);
    if (fd == -1) err_exit(open_err_msg);

    // 初始化→采集→清理
    camera_init(fd);
    capture_and_save(fd);
    cleanup(fd);

    printf("✅ 摄像头数据采集完成！\n");
    return EXIT_SUCCESS;
}
/////////////////
aarch64-linux-gnu-gcc v4l2.c -static -o v4l2
ffmpeg -f rawvideo -pixel_format yuv420p -video_size 1920x1080 -i test.yuv -vf "format=bgra" -f fbdev /dev/fb0

