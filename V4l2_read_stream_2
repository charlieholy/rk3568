(gdb) p video_devices[0]->name
$43 = "rkisp_mainpath", '\000' <repeats 17 times>
(gdb) p video_devices[2]->name
$44 = "rkisp_rawwr0", '\000' <repeats 19 times>
(gdb) p video_devices[1]->name
$45 = "rkisp_selfpath", '\000' <repeats 17 times>
(gdb) p video_devices[0]->name
$46 = "rkisp_mainpath", '\000' <repeats 17 times>
(gdb) p video_devices[1]->name
$47 = "rkisp_selfpath", '\000' <repeats 17 times>
(gdb) p video_devices[2]->name
$48 = "rkisp_rawwr0", '\000' <repeats 19 times>
(gdb) p video_devices[3]->name
$49 = "rkisp_rawwr2", '\000' <repeats 19 times>
(gdb) p video_devices[4]->name
$50 = "rkisp_rawwr3", '\000' <repeats 19 times>
(gdb) p video_devices[5]->name
$51 = "rkisp_rawrd0_m", '\000' <repeats 17 times>
(gdb) p video_devices[6]->name
$52 = "rkisp_rawrd2_s", '\000' <repeats 17 times>
(gdb) p video_devices[7]->name
$53 = "rkisp-statistics", '\000' <repeats 15 times>
(gdb) p video_devices[8]->name
$54 = "rkisp-input-params", '\000' <repeats 13 times>
(gdb) p video_devices[9]->name
$55 = "rkisp-isp-subdev", '\000' <repeats 15 times>
(gdb) p video_devices[10]->name
$56 = "rkisp-csi-subdev", '\000' <repeats 15 times>
(gdb) p video_devices[11]->name
$57 = "rockchip-csi2-dphy0", '\000' <repeats 12 times>
(gdb) p video_devices[12]->name
$58 = "m00_b_ov13850 4-0010", '\000' <repeats 11 times>
(gdb) p video_devices[13]->name
Cannot access memory at address 0x600

---Type <return> to continue, or q <return> to quit---^Cmagic = 37358Quit
(gdb) p q->ops->start_streaming
$26 = (int (*)(struct vb2_queue *, unsigned int)) 0xffffff80089eda10 <rkisp_start_streaming>
(gdb) p ((struct rkisp_stream*)q->drv_priv)->ispdev
$27 = (struct rkisp_device *) 0xffffffc0e6880080
(gdb) p q
$28 = (struct vb2_queue *) 0xffffffc0e6880d78

(gdb) p (p->subdevs[0])->name
$9 = "rkisp-csi-subdev", '\000' <repeats 15 times>
(gdb) p (p->subdevs[1])->name
$10 = "rockchip-csi2-dphy0", '\000' <repeats 12 times>
(gdb) p (p->subdevs[2])->name
$11 = "m00_b_ov13850 4-0010", '\000' <repeats 11 times>

phy -> sensor：启动视频流时，先启动 phy（接收端），后启动 sensor（发送端），避免数据丢失；
sensor -> phy：停止视频流时，先停止 sensor（发送端），后停止 phy（接收端），避免硬件卡死；
核心原则：数据流启停需遵循「接收端先就绪、发送端先关闭」的顺序，这是 MIPI CSI 硬件的通用规范；
底层逻辑：p->subdevs数组按phy在前、sensor在后排列，因此正向遍历是 phy→sensor，反向是 sensor→phy。
这个顺序是嵌入式 MIPI 摄像头开发的 “通用坑点”，如果顺序反了，会出现摄像头启动后无图像、停止后设备卡死等问题，

ubuntu20@NYX:~/opt/test$ ./a.out
VIDIOC_QUERYCAP:    2154321408 (0x80685600)
VIDIOC_ENUM_FMT:    3225441794 (0xC0405602)
VIDIOC_G_FMT:       3234878980 (0xC0D05604)
VIDIOC_S_FMT:       3234878981 (0xC0D05605)
VIDIOC_REQBUFS:     3222558216 (0xC0145608)
VIDIOC_QUERYBUF:    3227014665 (0xC0585609)
VIDIOC_G_FBUF:      2150651402 (0x8030560A)
VIDIOC_S_FBUF:      1076909579 (0x4030560B)
VIDIOC_OVERLAY:     1074025998 (0x4004560E)
VIDIOC_QBUF:        3227014671 (0xC058560F)
VIDIOC_EXPBUF:      3225441808 (0xC0405610)
VIDIOC_DQBUF:       3227014673 (0xC0585611)
VIDIOC_STREAMON:    1074026002 (0x40045612)
VIDIOC_STREAMOFF:   1074026003 (0x40045613)
ubuntu20@NYX:~/opt/test$ cat a.c
#include <stdio.h>
#include <linux/videodev2.h>  // 包含V4L2宏定义
#include <linux/ioctl.h>      // 包含_IO/_IOR/_IOW/_IOWR宏

int main() {
    // 打印所有命令的十进制和十六进制值
    printf("VIDIOC_QUERYCAP:    %u (0x%X)\n", VIDIOC_QUERYCAP, VIDIOC_QUERYCAP);
    printf("VIDIOC_ENUM_FMT:    %u (0x%X)\n", VIDIOC_ENUM_FMT, VIDIOC_ENUM_FMT);
    printf("VIDIOC_G_FMT:       %u (0x%X)\n", VIDIOC_G_FMT, VIDIOC_G_FMT);
    printf("VIDIOC_S_FMT:       %u (0x%X)\n", VIDIOC_S_FMT, VIDIOC_S_FMT);
    printf("VIDIOC_REQBUFS:     %u (0x%X)\n", VIDIOC_REQBUFS, VIDIOC_REQBUFS);
    printf("VIDIOC_QUERYBUF:    %u (0x%X)\n", VIDIOC_QUERYBUF, VIDIOC_QUERYBUF);
    printf("VIDIOC_G_FBUF:      %u (0x%X)\n", VIDIOC_G_FBUF, VIDIOC_G_FBUF);
    printf("VIDIOC_S_FBUF:      %u (0x%X)\n", VIDIOC_S_FBUF, VIDIOC_S_FBUF);
    printf("VIDIOC_OVERLAY:     %u (0x%X)\n", VIDIOC_OVERLAY, VIDIOC_OVERLAY);
    printf("VIDIOC_QBUF:        %u (0x%X)\n", VIDIOC_QBUF, VIDIOC_QBUF);
    printf("VIDIOC_EXPBUF:      %u (0x%X)\n", VIDIOC_EXPBUF, VIDIOC_EXPBUF);
    printf("VIDIOC_DQBUF:       %u (0x%X)\n", VIDIOC_DQBUF, VIDIOC_DQBUF);
    printf("VIDIOC_STREAMON:    %u (0x%X)\n", VIDIOC_STREAMON, VIDIOC_STREAMON);
    printf("VIDIOC_STREAMOFF:   %u (0x%X)\n", VIDIOC_STREAMOFF, VIDIOC_STREAMOFF);
    return 0;
}
ubuntu20@NYX:~/opt/test$

//test_pattern
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <sys/ioctl.h>
#include <linux/videodev2.h>

// 自定义ARRAY_SIZE宏（用户态通用，替代内核宏）
#ifndef ARRAY_SIZE
#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))
#endif

// 定义测试模式menu的映射（和驱动侧保持一致）
static const char *ov13850_test_pattern_str[] = {
    "Disabled",
    "Vertical Color Bar Type 1",
    "Vertical Color Bar Type 2",
    "Vertical Color Bar Type 3",
    "Vertical Color Bar Type 4"
};

// 函数：查看V4L2_CID_TEST_PATTERN的menu选项
static int query_test_pattern_menu(int fd) {
    struct v4l2_queryctrl qctrl = {0};
    qctrl.id = V4L2_CID_TEST_PATTERN;

    // 查询控件基本信息
    if (ioctl(fd, VIDIOC_QUERYCTRL, &qctrl) < 0) {
        perror("VIDIOC_QUERYCTRL failed (test pattern ctrl not exist?)");
        return -1;
    }

    printf("==== Test Pattern Control Info ====\n");
    printf("Name: %s\n", qctrl.name);
    printf("Min: %d, Max: %d, Default: %d\n", qctrl.minimum, qctrl.maximum, qctrl.default_value);
    printf("Menu Options:\n");

    // 遍历menu选项并打印
    struct v4l2_querymenu qmenu = {0};
    qmenu.id = V4L2_CID_TEST_PATTERN;
    for (qmenu.index = qctrl.minimum; qmenu.index <= qctrl.maximum; qmenu.index++) {
        if (ioctl(fd, VIDIOC_QUERYMENU, &qmenu) < 0) {
            perror("VIDIOC_QUERYMENU failed");
            continue;
        }
        printf("  %d: %s\n", qmenu.index, qmenu.name);
    }
    printf("====================================\n\n");
    return 0;
}

// 函数：设置测试模式
static int set_test_pattern(int fd, int value) {
    struct v4l2_control ctrl = {0};
    ctrl.id = V4L2_CID_TEST_PATTERN;
    ctrl.value = value;

    if (ioctl(fd, VIDIOC_S_CTRL, &ctrl) < 0) {
        perror("VIDIOC_S_CTRL failed");
        return -1;
    }
    printf("Set test pattern to: %d (%s)\n", value, 
           (value >=0 && value < ARRAY_SIZE(ov13850_test_pattern_str)) ? 
           ov13850_test_pattern_str[value] : "Unknown");
    return 0;
}

// 函数：读取当前测试模式
static int get_test_pattern(int fd) {
    struct v4l2_control ctrl = {0};
    ctrl.id = V4L2_CID_TEST_PATTERN;

    if (ioctl(fd, VIDIOC_G_CTRL, &ctrl) < 0) {
        perror("VIDIOC_G_CTRL failed");
        return -1;
    }
    printf("Current test pattern: %d (%s)\n", ctrl.value,
           (ctrl.value >=0 && ctrl.value < ARRAY_SIZE(ov13850_test_pattern_str)) ? 
           ov13850_test_pattern_str[ctrl.value] : "Unknown");
    return ctrl.value;
}

int main(int argc, char *argv[]) {
    if (argc != 3) {
        fprintf(stderr, "Usage: %s <video_dev> <test_pattern_value>\n", argv[0]);
        fprintf(stderr, "Example: %s /dev/video0 1 (set to Vertical Color Bar Type 1)\n", argv[0]);
        return -1;
    }

    // 1. 打开视频设备
    int fd = open(argv[1], O_RDWR);
    if (fd < 0) {
        perror("open video dev failed");
        return -1;
    }

    // 2. 查询测试模式的menu选项
    if (query_test_pattern_menu(fd) < 0) {
        close(fd);
        return -1;
    }

    // 3. 设置测试模式（参数2为要设置的值）
    int target_value = atoi(argv[2]);
    if (set_test_pattern(fd, target_value) < 0) {
        close(fd);
        return -1;
    }

    // 4. 读取并验证设置结果
    get_test_pattern(fd);

    // 5. 关闭设备
    close(fd);
    return 0;
}

///

root@ATK-DLRK3568:/data# ./v4l2TestPt /dev/video0 3
==== Test Pattern Control Info ====
Name: Test Pattern
Min: 0, Max: 4, Default: 0
Menu Options:
  0: Disabled
  1: Vertical Color Bar Type 1
  2: Vertical Color Bar Type 2
  3: Vertical Color Bar Type 3
  4: Vertical Color Bar Type 4
====================================

Set test pattern to: 3 (Vertical Color Bar Type 3)
Current test pattern: 3 (Vertical Color Bar Type 3)

open camera 
