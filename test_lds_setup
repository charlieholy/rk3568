

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

// ===================== 1. 定义核心结构体（模拟内核 obs_kernel_param）=====================
// 自定义参数处理结构体：对应内核的 struct obs_kernel_param
typedef struct {
    const char *param_name;          // 参数名（如 "demo="）
    int (*handler)(const char *arg); // 参数处理函数
} my_setup_param_t;

// ===================== 2. 定义自定义段和注册宏（模拟内核 __setup 宏）=====================
// 定义段边界的"哨兵"变量（GCC 会按声明顺序排列段内变量，所以把 start/end 放在段的首尾）
// 注意：这里用 __attribute__((used)) 防止编译器优化掉这些变量
my_setup_param_t __my_setup_start __attribute__((used, section("my_setup"))) = {0};
my_setup_param_t __my_setup_end   __attribute__((used, section("my_setup"))) = {0};

// 自定义宏：模拟内核 __setup 宏，把处理函数注册到 my_setup 段
#define MY_SETUP(param_str, func) \
    static my_setup_param_t __setup_##func \
    __attribute__((used, section("my_setup"))) = { \
        .param_name = param_str, \
        .handler = func \
    }

// ===================== 3. 定义示例参数处理函数（模拟内核的 kgdboc_option_setup）=====================
// 处理 "demo=" 参数的函数
static int demo_param_handler(const char *arg) {
    printf("demo_param_handler 被调用，参数值：%s\n", arg ? arg : "空");
    return 0;
}

// 处理 "test=" 参数的函数
static int test_param_handler(const char *arg) {
    printf("test_param_handler 被调用，参数值：%s\n", arg ? arg : "空");
    return 0;
}

// 注册上述函数到 my_setup 段（模拟内核 __setup("kgdboc=", kgdboc_option_setup)）
MY_SETUP("demo=", demo_param_handler);
MY_SETUP("test=", test_param_handler);

// ===================== 4. 遍历自定义段 + 匹配参数（模拟内核 do_setup/parse_args）=====================
// 遍历 my_setup 段，匹配参数并调用处理函数
static int parse_my_param(const char *param) {
    my_setup_param_t *p;
    int matched = 0;

    // 遍历 my_setup 段：从 __my_setup_start 下一个元素开始，到 __my_setup_end 结束
    // （因为 __my_setup_start 是段的起始哨兵，第一个有效元素在它之后）
    for (p = &__my_setup_start + 1; p < &__my_setup_end; p++) {
        if (!p->param_name || !p->handler)
            continue;

        // 匹配参数名（比如 param 是 "demo=123"，匹配 p->param_name "demo="）
        size_t name_len = strlen(p->param_name);
        if (strncmp(param, p->param_name, name_len) == 0) {
            // 调用处理函数，传入参数值（比如 "123"）
            p->handler(param + name_len);
            matched = 1;
        }
    }

    if (!matched) {
        printf("未找到匹配的参数处理函数：%s\n", param);
    }
    return matched;
}

// ===================== 5. 主函数（模拟内核 start_kernel）=====================
int main(int argc, char *argv[]) {
    // 模拟内核启动参数列表
    const char *kernel_params[] = {
        "demo=hello_world",
        "test=123456",
        "unknown=789",
        NULL
    };

    printf("==== 开始解析自定义参数 ====\n");
    // 遍历所有模拟的启动参数，解析并调用处理函数
    for (int i = 0; kernel_params[i]; i++) {
        parse_my_param(kernel_params[i]);
    }

    // 额外演示：打印自定义段的地址范围（验证段的存在）
    printf("\n==== 自定义段 my_setup 信息 ====\n");
    printf("__my_setup_start 地址：%p\n", &__my_setup_start);
    printf("__my_setup_end   地址：%p\n", &__my_setup_end);
    printf("段内元素数量：%ld\n", (&__my_setup_end - &__my_setup_start - 1));

    return 0;
}


gcc -o setup_demo setup_demo.c -Wall

==== 开始解析自定义参数 ====
demo_param_handler 被调用，参数值：hello_world
test_param_handler 被调用，参数值：123456
未找到匹配的参数处理函数：unknown=789

==== 自定义段 my_setup 信息 ====
__my_setup_start 地址：0x55f8b826e010
__my_setup_end   地址：0x55f8b826e038
段内元素数量：2
