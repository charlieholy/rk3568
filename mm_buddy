阶段 1：内存描述符初始化（搭好 “骨架”）
核心目标：创建物理页的描述符（struct page）、内存节点（pg_data_t）、内存域（zone）等基础结构，为伙伴系统提供 “管理载体”。
1.1 初始化 struct page 数组（页描述符）

1.2 初始化内存节点（pg_data_t）和内存域（zone）
核心函数：free_area_init_nodes() → free_area_init_node() → pgdat_init()（mm/page_alloc.c）
作用

阶段 2：free_area 管理结构初始化（建好 “货架”）
核心目标：初始化 free_area 的核心成员（空闲链表、计数），为存放空闲页搭好 “货架”。
2.1 核心函数：free_area_init_core()（mm/page_alloc.c）

阶段 3：空闲页填充到伙伴链表（摆满 “商品”）
核心目标：把系统中未被保留的空闲物理页，逐个释放到伙伴系统的 free_list 中，让伙伴系统真正具备 “分配能力”。
3.1 核心函数：memblock_free_all()（mm/memblock.c）
作用：遍历 memblock 管理的所有空闲物理内存，把这些页释放到伙伴系统中；
底层调用链：memblock_free_all() → __free_pages_core() → free_one_page() → add_to_free_list()。

阶段 4：伙伴系统进入可用状态（开放 “仓库”）
核心目标：完成最后的初始化收尾，让伙伴系统对外提供分配接口。
4.1 核心动作
初始化每 CPU 页缓存（PCP）：为每个 CPU 创建小批量页缓存，减少伙伴系统的锁竞争；
初始化内存回收机制：关联 kswapd 进程、页回收策略，保证内存不足时能回收页补充到伙伴系统；
对外暴露分配接口：alloc_pages()、__get_free_pages() 等函数指向伙伴系统的分配逻辑；
4.2 可用标志：page_alloc_ready


定位第3阶段
b  memblock_free_all
p &(node_data[0].node_zones)[0].free_area[0].nr_free
watch *$5
c

(gdb) c
Continuing.

Hardware watchpoint 2: *$5

Old value = 0
New value = 1
__free_one_page (page=0xfffffc000008a180, pfn=270982, zone=0xffff000007fb3c00, order=0, migratetype=1, fpi_flags=6) at mm/page_alloc.c:1148
1148            if (!(fpi_flags & FPI_SKIP_REPORT_NOTIFY))

extern struct memblock memblock;

(gdb) p (node_data[0].node_zones)[0]
$8 = {_watermark = {0, 0, 0}, watermark_boost = 0, nr_reserved_highatomic = 0, lowmem_reserve = {0, 0, 0, 0},
  node = 0, zone_pgdat = 0xffff000007fb3c00, per_cpu_pageset = 0xffff800009839718 <boot_pageset>,
  per_cpu_zonestats = 0xffff800009839818 <boot_zonestats>, pageset_high = 0, pageset_batch = 1,
  zone_start_pfn = 262144, managed_pages = <incomplete type>, spanned_pages = 32768, present_pages = 32768,
  cma_pages = 0, name = 0xffff8000095a2ca0 "DMA", nr_isolate_pageblock = 0, initialized = 1, _pad1_ = {
    x = 0xffff000007fb3cc0 "\310\002\t"}, free_area = {{free_list = 0xffff000007fb3cc0, nr_free = 2}, {
      free_list = 0xffff000007fb3d28, nr_free = 5}, {free_list = 0xffff000007fb3d90, nr_free = 2}, {
      free_list = 0xffff000007fb3df8, nr_free = 2}, {free_list = 0xffff000007fb3e60, nr_free = 5}, {
      free_list = 0xffff000007fb3ec8, nr_free = 3}, {free_list = 0xffff000007fb3f30, nr_free = 4}, {
      free_list = 0xffff000007fb3f98, nr_free = 2}, {free_list = 0xffff000007fb4000, nr_free = 5}, {
      free_list = 0xffff000007fb4068, nr_free = 4}, {free_list = 0xffff000007fb40d0, nr_free = 11}}, flags = 0,
  lock = <incomplete type>, _pad2_ = {x = 0xffff000007fb4180 ""}, percpu_drift_mark = 0, compact_cached_free_pfn = 0,
  compact_cached_migrate_pfn = {0, 0}, compact_init_migrate_pfn = 0, compact_init_free_pfn = 0,
  compact_considered = 0, compact_defer_shift = 0, compact_order_failed = 0, compact_blockskip_flush = false,
  contiguous = false, _pad3_ = {x = 0xffff000007fb41c0 "\325;"}, vm_stat = 0xffff000007fb41c0,
  vm_numa_event = 0xffff000007fb4210}


root@ATK-DLRK3568:/data# cat /proc/slabinfo
# name            <active_objs> <num_objs> <objsize> <objperslab> <pagesperslab> : tunables <limit> <batchcount> <sharedfactor> : slabdata <active_slabs> <num_slabs> <sharedavail>
PING                   0      0   1152   28    8 : tunables    0    0    0 : slabdata      0      0      0
ping 127.0.0.1
PING                  28     28   1152   28    8 : tunables    0    0    0 : slabdata      1      1      0

////////////////////  
(gdb) p slab_caches.next.next.next
$47 = (struct list_head *) 0xffffffc0e7e22360
(gdb) p /x 0xffffffc0e7e22360 - 0x60
$48 = 0xffffffc0e7e22300
(gdb) p *(struct kmem_cache *)0xffffffc0e7e22300
$49 = {cpu_slab = 0xffffff7dd9526ae0, flags = 1073872896, min_partial = 5, size = 928, object_size = 920, offset = 920, cpu_partial = 13, oo = {
    x = 131089}, max = {x = 131089}, min = {x = 4}, allocflags = 16400, refcount = 1, ctor = 0xffffff80083899d4 <inode_slab_ctor>, inuse = 920, align = 8,
  red_left_pad = 0, name = 0xffffff8009135ab1 "ubifs_inode_slab", list = {next = 0xffffffc0e75b8660, prev = 0xffffffc0e7ad61e0}, kobj = {
    name = 0xffffff8009135ab1 "ubifs_inode_slab", entry = {next = 0xffffffc0e7ad61f8, prev = 0xffffffc0e75b8678}, parent = 0xffffffc0e8e45828,
    kset = 0xffffffc0e8e45800, ktype = 0xffffff80094a3340 <slab_ktype>, sd = 0xffffffc0e755fa18, kref = {refcount = {refs = {counter = 1}}},
    state_initialized = 1, state_in_sysfs = 1, state_add_uevent_sent = 1, state_remove_uevent_sent = 0, uevent_suppress = 0, android_kabi_reserved1 = 0,
    android_kabi_reserved2 = 0, android_kabi_reserved3 = 0, android_kabi_reserved4 = 0}, kobj_remove_work = {data = {counter = 68719476704}, entry = {
      next = 0xffffffc0e7e223d8, prev = 0xffffffc0e7e223d8}, func = 0xffffff800820b9a4 <sysfs_slab_remove_workfn>, android_kabi_reserved1 = 0,
    android_kabi_reserved2 = 0}, useroffset = 0, usersize = 0, node = {0xffffffc0e7e01600}}
(gdb)
